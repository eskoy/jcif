#define GROUP_COUNT 4096
#define GROUP_SIZE 512
#define GRID_SIZE   (GROUP_COUNT*GROUP_SIZE)
layout(local_size_x=GROUP_SIZE) in;
const int globalId=int(gl_GlobalInvocationID.x);
layout(std430, binding = 0) volatile coherent buffer SSBO_0 {    
int counts[];
 };
layout(std430, binding = 1) restrict readonly buffer SSBO_1 {
uint bitmask[]; 
};
layout(std430, binding = 2) restrict readonly buffer SSBO_2 {
float valuesA[];
};
layout(std430, binding = 3) restrict readonly buffer SSBO_3 {
float valuesB[];
};
layout(std430, binding = 4) restrict readonly buffer SSBO_4 {
float valuesC[];
};
layout(location=0) uniform ivec4 UNI_0;
const int pulseCount = UNI_0.x;
const ivec3 binCount  = UNI_0.yzw;
layout(location=1) uniform vec3 UNI_1;
const vec3 factor= UNI_1.xyz;
layout(location=2) uniform vec3 UNI_2;
const vec3 increment= UNI_2.xyz;
void main(void)
{
const ivec3 firstBin=ivec3(0);
const ivec3 lastBin=binCount-ivec3(1);
for(int id=globalId;id<pulseCount;id+=GRID_SIZE)
{
if((bitmask[id])!=0)
{
const vec3 value=vec3(valuesA[id],valuesB[id],valuesC[id]); 
const vec3 pos=fma(value,factor,increment); 
const ivec3 bin=clamp(ivec3(floor(pos)),firstBin,lastBin);
const int binId=(bin.z*binCount.y+bin.y)*binCount.x+bin.x;  
atomicAdd(counts[binId],1);
}
}
}